<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>JS5-4.this 키워드2</title>

    <script>
      /* 
                [ 타이밍 함수 내부의 this 키워드 의미! ]
            */

      // 객체생성하기1
      const codingObj1 = {
        name: "말코랑",
        codeLine: 300,
        showMsg: function () {
            console.log(this.name + "님, 오늘은 " + this.codeLine + "줄 코딩하셨네요!");
          // 타이밍함수에 출력
          setTimeout(function () {
            console.log(this.name + "님, 추가코딩으로 " +  this.codeLine +  "줄 코딩하셨네요!", this);
          }, 500);
          // queue 에서 대기하다가 나중에 실행되기 때문에 undefined
          // 나중에 실행되므로 this를 읽을 수 없음
        },
      }; ////////// codingObj1 ///////////////////

      // 객체 메서드 호출
      codingObj1.showMsg();

      // 객체생성하기2
      const codingObj2 = {
        name: "호랑말코",
        codeLine: 500,
        showMsg: function () {
          console.log(this.name + "님, 오늘은 " + this.codeLine + "줄 코딩하셨네요!");
          // 타이밍함수에 출력
          setTimeout(
            function () {
              console.log(this.name + "님, 추가코딩으로 " +  this.codeLine +  "줄 코딩하셨네요!", this);
            }.bind(this),
            500
          );
          // bind(this)
          // 타이밍 함수의 실행 구역이 달라짐에 따라 this의 의미가 전달되지 않으므로 bind메서드로 전달함
        },
      }; ////////// codingObj1 ///////////////////

      // 객체 메서드 호출
      codingObj2.showMsg();

      // 객체생성하기3
      const codingObj3 = {
        name: "쇼호랑",
        codeLine: 1000,
        showMsg: function () {
          console.log(this.name + "님, 오늘은 " + this.codeLine + "줄 코딩하셨네요!");

          // 타이밍함수에 출력
          setTimeout(() => {
            console.log(this.name + "님, 추가코딩으로 " + this.codeLine + "줄 코딩하셨네요!",this);
          }, 500);
          // 화살표함수를 사용하면 queue 실행 구역에 this를 bind 메서드 사용 없이 전달 가능하다
        },
      }; ////////// codingObj1 ///////////////////

      // 객체 메서드 호출
      codingObj3.showMsg();
    </script>
  </head>

  <body></body>
</html>
